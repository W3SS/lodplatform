/*******************************************************************************
 *
 * Pentaho Data Integration
 *
 * Copyright (C) 2002-2012 by Pentaho : http://www.pentaho.com
 *
 *******************************************************************************
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

package com.ucuenca.pentaho.plugin.step;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.pentaho.di.core.exception.KettleException;
import org.pentaho.di.core.row.RowDataUtil;
import org.pentaho.di.core.row.RowMeta;
import org.pentaho.di.core.row.RowMetaInterface;
import org.pentaho.di.trans.Trans;
import org.pentaho.di.trans.TransMeta;
import org.pentaho.di.trans.step.BaseStep;
import org.pentaho.di.trans.step.StepDataInterface;
import org.pentaho.di.trans.step.StepInterface;
import org.pentaho.di.trans.step.StepMeta;
import org.pentaho.di.trans.step.StepMetaInterface;

//-----------------------
import org.apache.jena.atlas.lib.FileOps;
import org.apache.jena.fuseki.Fuseki;
import org.apache.jena.fuseki.server.FusekiVocab;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DefaultLogger;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectHelper;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.MessageBox;
import org.eclipse.swt.widgets.Shell;

import com.hp.hpl.jena.ontology.OntModel;
import com.hp.hpl.jena.ontology.OntModelSpec;
import com.hp.hpl.jena.query.DatasetFactory;
import com.hp.hpl.jena.query.ReadWrite;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.ModelFactory;
import com.hp.hpl.jena.rdf.model.RDFNode;
import com.hp.hpl.jena.rdf.model.Resource;
import com.hp.hpl.jena.rdf.model.ResourceFactory;
import com.hp.hpl.jena.sparql.core.DatasetGraph;
import com.hp.hpl.jena.tdb.TDBFactory;
import com.hp.hpl.jena.tdb.base.file.Location;
import com.hp.hpl.jena.vocabulary.RDF;
import com.hp.hpl.jena.vocabulary.RDFS;
import com.hp.hpl.jena.query.Dataset;

import com.hp.hpl.jena.vocabulary.*;

//-------------------librerias XML
import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

//-------------------

/** .
 * @author Fabian Pe√±aloza Marin
 * @version 1
 */
/**
 * This class is part of the demo step plug-in implementation. It demonstrates
 * the basics of developing a plug-in step for PDI.
 * 
 * The demo step adds a new string field to the row stream and sets its value to
 * "Hello World!". The user may select the name of the new field.
 * 
 * This class is the implementation of StepInterface. Classes implementing this
 * interface need to:
 * 
 * - initialize the step - execute the row processing logic - dispose of the
 * step
 * 
 * Please do not create any local fields in a StepInterface class. Store any
 * information related to the processing logic in the supplied step data
 * interface instead.
 * 
 */

public class EldaPDIStep extends BaseStep implements StepInterface {

	private Model fModel = ModelFactory.createDefaultModel();
	private String  nombreConfiguracion  = "";   //nombre para crear la configuracion

	/**
	 * The constructor should simply pass on its arguments to the parent class.
	 * 
	 * @param s
	 *            step description
	 * @param stepDataInterface
	 *            step data class
	 * @param c
	 *            step copy
	 * @param t
	 *            transformation description
	 * @param dis
	 *            transformation executing
	 */
	public EldaPDIStep(StepMeta s, StepDataInterface stepDataInterface, int c,
			TransMeta t, Trans dis) {
		super(s, stepDataInterface, c, t, dis);
	}

	/**
	 * This method is called by PDI during transformation startup.
	 * 
	 * It should initialize required for step execution.
	 * 
	 * The meta and data implementations passed in can safely be cast to the
	 * step's respective implementations.
	 * 
	 * It is mandatory that super.init() is called to ensure correct behavior.
	 * 
	 * Typical tasks executed here are establishing the connection to a
	 * database, as wall as obtaining resources, like file handles.
	 * 
	 * @param smi
	 *            step meta interface implementation, containing the step
	 *            settings
	 * @param sdi
	 *            step data interface implementation, used to store runtime
	 *            information
	 * 
	 * @return true if initialization completed successfully, false if there was
	 *         an error preventing the step from working.
	 * 
	 */
	/*
	 * public boolean init(StepMetaInterface smi, StepDataInterface sdi) { //
	 * Casting to step-specific implementation classes is safe FusekiLoaderMeta
	 * meta = (FusekiLoaderMeta) smi; FusekiLoaderData data = (FusekiLoaderData)
	 * sdi;
	 * 
	 * return super.init(meta, data); }
	 */
	/**
	 * Once the transformation starts executing, the processRow() method is
	 * called repeatedly by PDI for as long as it returns true. To indicate that
	 * a step has finished processing rows this method must call setOutputDone()
	 * and return false;
	 * 
	 * Steps which process incoming rows typically call getRow() to read a
	 * single row from the input stream, change or add row content, call
	 * putRow() to pass the changed row on and return true. If getRow() returns
	 * null, no more rows are expected to come in, and the processRow()
	 * implementation calls setOutputDone() and returns false to indicate that
	 * it is done too.
	 * 
	 * Steps which generate rows typically construct a new row Object[] using a
	 * call to RowDataUtil.allocateRowData(numberOfFields), add row content, and
	 * call putRow() to pass the new row on. Above process may happen in a loop
	 * to generate multiple rows, at the end of which processRow() would call
	 * setOutputDone() and return false;
	 * 
	 * @param smi
	 *            the step meta interface containing the step settings
	 * @param sdi
	 *            the step data interface that should be used to store
	 * 
	 * @return true to indicate that the function should be called again, false
	 *         if the step is done
	 */
	public boolean processRow(StepMetaInterface smi, StepDataInterface sdi)
			throws KettleException {

		// safely cast the step settings (meta) and runtime info (data) to
		// specific implementations
		EldaPDIStepMeta meta = (EldaPDIStepMeta) smi;
		EldaPDIStepData data = (EldaPDIStepData) sdi;
		getRow();
		String status = "ERROR";
		if (meta.getValidate().equals("true")) {
			// the "first" flag is inherited from the base step implementation
			// it is used to guard some processing tasks, like figuring out
			// field
			// indexes
			// in the row structure that only need to be done once
			if (first) {
				first = false;

				super.init(meta, data);
				data.outputRowMeta = getInputRowMeta() != null ? getInputRowMeta()
						.clone() : new RowMeta();
				// data.outputRowMeta = (RowMetaInterface)
				// getInputRowMeta().clone();
				try {
					data.model.read(meta.getOutputField().trim());

				} catch (Exception eox) {
					logBasic(" ERROR " + eox + " Unload model "
							+ meta.getOutputField());
				}
				//tranformacion a dataset
				String name = meta.getInputName().replaceFirst("[.][^.]+$", ""); 
				
				
				 nombreConfiguracion = ObtenerNombreUrl(meta.getEbaseUri());

				
				String FileName = nombreConfiguracion+".ttl";
				
				// create mapping.ttl-------------------------------------
				
				
				createmapping(meta, FileName);

				logBasic(" config data is ok ");

				try {
					/**
					 * File source=new
					 * File("plugins/steps/FusekiLoader/fuseki.war"); File
					 * destination=new File(meta.getDirectory()+"/fuseki.war");
					 */

					// create destination
					File dir = new File(meta.getDirectory() + "/elda");
					dir.mkdir();
					//
					File source = new File("plugins/steps/EldaPDIStep/elda");
					File destination = new File(meta.getDirectory() + "/elda");

					recursiveCopy(source, destination);
					
					//configurar base URI   name
					parametrizarUri(source, destination, nombreConfiguracion);
					
					// copyFile(source,destination);
					// crear war
					crearwar(destination.toString());

					logBasic("The elda was build succesfully in "
							+ meta.getDirectory() + "/" + "elda");

				} catch (Exception e1) {

					logBasic(" ERROR " + e1 + "The File was not created. in "
							+ meta.getDirectory() + "/" + "elda");
				}

			}

			// safely add the string "Hello World!" at the end of the output row
			// the row array will be resized if necessary

			// getinputrowmeta (directorio , ok);
			// setoutputdown
			status = "OK";

			// put the row to the output row stream
			// putRow(meta.get, outputRow);
			// Object[] outputRow =
			// RowDataUtil.allocateRowData(data.outputRowMeta
			// .size());

			Object[] outputRow = new Object[2];

			outputRow[0] = meta.getDirectory() + "/elda";
			outputRow[1] = status;
			putRow(data.outputRowMeta, outputRow);

			// log progress if it is time to to so
			if (checkFeedback(getLinesRead())) {
				logBasic("Linenr " + getLinesRead()); // Some basic logging
			}
		} else {

			logBasic(" ERROR Tranformation dont started , because parameters es empty");

			status = "ERROR";
		}
		// indicate that processRow() should be called again
		return false;
	}
	
	private void AgregarParametroWeb(String name) {
		
		 try {
				String filepath = "plugins/steps/EldaPDIStep/elda/webapps/standalone/WEB-INF/web.xml";
				DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
				DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
				Document doc = docBuilder.parse(filepath);
				
				
				// Get the root element
				Node principal = doc.getFirstChild();
				
				Node staff = doc.getElementsByTagName("param-value").item(0);
				
				
				Element age = doc.createElement(name+"::/specs/"+name+".ttl");
				staff.appendChild(age);
				
				
				// write the content into xml file
				TransformerFactory transformerFactory = TransformerFactory.newInstance();
				Transformer transformer = transformerFactory.newTransformer();
				DOMSource source = new DOMSource(doc);
				StreamResult result = new StreamResult(new File(filepath));
				transformer.transform(source, result);

				System.out.println("Done");
				
		 } catch (ParserConfigurationException pce) {
				pce.printStackTrace();
			   } catch (TransformerException tfe) {
				tfe.printStackTrace();
			   } catch (IOException ioe) {
				ioe.printStackTrace();
			   } catch (SAXException sae) {
				sae.printStackTrace();
			   }
	}

	/**
	 * MEtodo necesario para obtener el nombre a configurar en el web.xml
	 * @param ebaseUri
	 * @return String del nombre ultimo del url
	 */
	private String ObtenerNombreUrl(String ebaseUri) {
		String resp= "";
		
		//System.out.println("base Uri "+ebaseUri);
		for(int i=ebaseUri.length()-1; i>=0;i--){
			//System.out.println("i  "+i + " "+ebaseUri.substring(i,i));
		    if (ebaseUri.substring(i,i+1).compareTo("/")!=0){
		    	resp = ebaseUri.substring(i,i+1)+resp;
		    }else if(i!=ebaseUri.length()-1){
		    	i=-1; //termino de concatenar
		    }
		  }
		
		//System.out.println("base urif "+resp);
		return resp;
	}

	private void createmapping(EldaPDIStepMeta meta,String FileName) {
		List<String> myListSelect;
		myListSelect = cleanspaces(meta.getListSelect());
		
		List<String> myListProper;
		myListProper = cleanspaces(meta.getListProper());
		
		List<String> myListSelectNames;
		myListSelectNames = cargaListaTodos(meta.getListSelectNames());//myListSelectNames = cleanspaces(meta.getListSelectNames());
		
		List<String> myListProperNames;
		myListProperNames = cargaListaTodos(meta.getListProperNames());
		
		int val = 99;

		logBasic(" llego al mapping " + meta.getInputName());

		// conf principal

		// API END POINT

		 		//nombre "example-data.ttl"; Resource subresL = fModel.createResource("local:data/" + nombre);
		logBasic(" sparqlEndpoint : " + meta.getServicio());
		Resource subresL = fModel.createResource(meta.getServicio());   //poner la url del servicio 
		
		//String urlconfig = meta.getEbaseUri(); .createResource(
	//"http://epimorphics.com/public/vocabulary/games.ttl#hello-world")
		logBasic(" URL configuracion : " + meta.getEbaseUri());
		String URLconfiguracion = meta.getEbaseUri();
		
		Resource resourcePrin = fModel
				.createResource(
						URLconfiguracion + "#"+nombreConfiguracion)
				.addProperty(RDF.type, api.API)
				.addProperty(api.sparqlEndpoint, subresL)
				.addProperty(api.defaultViewer, api.labelledDescribeViewer)
				.addProperty(
						api.viewer,
						fModel.createResource()
								.addProperty(RDF.type, api.Viewer)
								.addProperty(api.name, "empty")
								.addProperty(api.properties, ""))
				.addProperty(
						api.variable,
						fModel.createResource()
								.addProperty(api.name, "_velocityRoot")
								.addProperty(api.value,
										"http://localhost:8080/standalone/lda-assets/vm/"))
				.addProperty(
						api.variable,
						fModel.createResource()
								.addProperty(api.name, "_resourceRoot")
								.addProperty(api.value,
										"/standalone/lda-assets/"))
				/*.addProperty(api.endpoint,
						"http://epimorphics.com/public/vocabulary/games.ttl#publisher")
				.addProperty(api.endpoint,
						"http://epimorphics.com/public/vocabulary/games.ttl#games")
				.addProperty(api.endpoint,
						"http://epimorphics.com/public/vocabulary/games.ttl#about")*/

				
				//VelocityFormatter
				.addProperty(
						api.formatter,
						fModel.createResource()
								.addProperty(RDF.type, elda.VelocityFormatter)
								.addProperty(api.name, "vhtml")
								.addProperty(elda.className,
										"com.epimorphics.lda.renderers.VelocityRendererFactory")
								.addProperty(api.mimeType,
										"text/html")
								.addProperty(elda.velocityTemplate,
										"page-shell.vm"))
				// Atom Formatter
				/*					 
					.addProperty(
						api.formatter,
						fModel.createResource()
								.addProperty(RDF.type, elda.FeedFormatter)
								.addProperty(api.name, "atom")
								.addProperty(elda.className,
										"com.epimorphics.lda.renderers.FeedRendererFactory")
								.addProperty(api.mimeType,
										"application/atom+xml"))						
					*/
										
										
				.addProperty(elda.enableCounting, "true")
				.addProperty(elda.cacheExpiryTime, "10s");
		
				//formater css 
				

		
		// listPoint Configurations Entidades
;

		for (int i=0 ; i<myListSelect.size(); i++){
			// listPoint hello:publishers
			String nlabel = myListSelect.get(i).substring(myListSelect.get(i).lastIndexOf("#")+1, myListSelect.get(i).length());
			if (nlabel.length() == myListSelect.get(i).length()){ nlabel = myListSelect.get(i).substring(myListSelect.get(i).lastIndexOf("/")+1, myListSelect.get(i).length());
			 }
			String namer = (myListSelect.get(i)+"s").toLowerCase(); 
			System.out.println(nlabel+ " "+namer);
			String nombreURI = "";
			//revisar si el usuario puso un nombre
			if (myListSelectNames.get(i).trim().isEmpty() || (myListSelectNames.get(i)==null)){
				nombreURI = "/"+nlabel.toLowerCase()+'s' ;
			}else {
				nombreURI = "/"+myListSelectNames.get(i).trim();
			}
			
			Resource resourceL = fModel
					.createResource(namer);
			resourceL
					.addProperty(RDF.type, api.ListEndpoint)
					.addProperty(RDFS.label, nlabel+'s')
					.addProperty(api.uriTemplate, nombreURI) 
					.addProperty(
							api.selector,
							fModel.createResource()
									.addProperty(api.filter, "type="+nlabel)
									.addProperty(api.sort, "label"))
					.addProperty(api.defaultViewer, api.labelledDescribeViewer);
			
			
			resourcePrin.addProperty(api.endpoint,resourceL);  //agregar listEnpoint al resource principal
			
			//class

			Resource resourceC = fModel
					.createResource(
							myListSelect.get(i))
					.addProperty(RDF.type, RDFS.Class)
					.addProperty(api.label, nlabel);
			;
			
		}
		
		
		// ItemEndpoint
		Resource resourceE = fModel
				//.createResource("http://epimorphics.com/public/vocabulary/games.ttl#about");
				.createResource(URLconfiguracion +"#about");
		resourceE.addProperty(RDF.type, api.ItemEndpoint)
		.addProperty(RDFS.label,"About")
		.addProperty(api.uriTemplate, "/about?resource={uri}")
		.addProperty(api.itemTemplate, "{uri}")
		.addProperty(api.variable, 
				fModel.createResource()
				.addProperty(api.name,fModel.createResource()
						.addProperty(api.type,RDFS.Resource))
				)
		.addProperty(api.selector, fModel.createResource()
				.addProperty(api.where, "?item ?p ?o. FILTER(?item = ?uri)")
				.addProperty(api.sort, "label")
				)	
		.addProperty(api.defaultViewer,api.labelledDescribeViewer)		
		;
		resourcePrin.addProperty(api.endpoint,resourceE);
		
		//propiedades 
		for (int k=0 ; k<myListProper.size(); k++){
			String nlabel = "";
			//validacion url vacia
			if (!myListProper.get(k).isEmpty()){
				if (myListProperNames.size() > k){
					 if(myListProperNames.get(k).trim().isEmpty() || (myListProperNames.get(k).trim()==null))
					 {	//si esta vacio lo ingreso por defecto  
						 nlabel = myListProper.get(k).substring(myListProper.get(k).lastIndexOf("#")+1, myListProper.get(k).length());
						if (nlabel.length() == myListProper.get(k).length()){ nlabel = myListProper.get(k).substring(myListProper.get(k).lastIndexOf("/")+1, myListProper.get(k).length());
						 }
					 }else{
						 nlabel = myListProperNames.get(k).trim();
					 }
				}else {
					 nlabel = myListProper.get(k).substring(myListProper.get(k).lastIndexOf("#")+1, myListProper.get(k).length());
						if (nlabel.length() == myListProper.get(k).length()){ nlabel = myListProper.get(k).substring(myListProper.get(k).lastIndexOf("/")+1, myListProper.get(k).length());
						 }
				}
					 
				// propiedad
				Resource resourceP = fModel
						.createResource(myListProper.get(k));
				resourceP.addProperty(RDF.type, RDF.Property).addProperty(api.label,
						nlabel);
			}
		}
		
		
		
		// resourceC.addProperty(RDFS.class, "#publisher")
		
		//opcional formater para Atom
		/*
		Resource resourceFormato = fModel
				.createResource(
						URLconfiguracion + "#"+"HtmlFormatter")
				.addProperty(RDF.type, api.XsltFormatter)
				.addProperty(api.name, "html")
				.addProperty(api.mimeType, "text/html; charset=utf-8")
				.addProperty(api.stylesheet, "lda-assets/xslt/result-osm-trimmed.xsl");
		resourcePrin.addProperty(api.defaultFormatter,resourceFormato);		
	*/


		FileWriter out;
		try {
			
//			out = new FileWriter("plugins/steps/EldaPDIStep/elda/webapps/standalone/specs/"
//					+ "hello-again-world.ttl");
			
			out = new FileWriter("plugins/steps/EldaPDIStep/elda/webapps/standalone/specs/"
					+ FileName);
			
			fModel.write(out, "TTL"); //escribo el modelo en un archivo
			logBasic( "The File config "+FileName+" was  created ");
			

		} catch (IOException e) {

			logBasic(e.toString());

		}

		try {
			
			
			String line = "", oldtext = "";
			/*	File file = new File("plugins/steps/EldaPDIStep/elda/configO.ttl");
			BufferedReader reader = new BufferedReader(new FileReader(file));
			 * while ((line = reader.readLine()) != null) {
				oldtext += line + "\r\n";
			}
			reader.close();
			
			oldtext="";*/
			
			//File file = new File("plugins/steps/EldaPDIStep/elda/webapps/standalone/specs/hello-again-world.ttl");
			File file = new File("plugins/steps/EldaPDIStep/elda/webapps/standalone/specs/"+FileName);
			BufferedReader reader2 = new BufferedReader(new FileReader(file));
			String line2 = "", oldtext2 = "";
			while ((line2 = reader2.readLine()) != null) {
				oldtext2 += line2 + "\r\n";
			}
			reader2.close();

			String newtext = oldtext + "" + oldtext2;

			FileWriter writer = new FileWriter(
					"plugins/steps/EldaPDIStep/elda/webapps/standalone/specs/" + "hello-again-world.ttl");
			writer.write(newtext);

			writer.close();

		} catch (IOException ioe) {
			logBasic(" ERROR " + ioe + "The File config "+FileName+" was not created. ");
			ioe.printStackTrace();

		}

	}
	
	

	/**
	 * This method is called by PDI once the step is done processing.
	 * 
	 * The dispose() method is the counterpart to init() and should release any
	 * resources acquired for step execution like file handles or database
	 * connections.
	 * 
	 * The meta and data implementations passed in can safely be cast to the
	 * step's respective implementations.
	 * 
	 * It is mandatory that super.dispose() is called to ensure correct
	 * behavior.
	 * 
	 * @param smi
	 *            step meta interface implementation, containing the step
	 *            settings
	 * @param sdi
	 *            step data interface implementation, used to store runtime
	 *            information
	 */
	public void dispose(StepMetaInterface smi, StepDataInterface sdi) {

		// Casting to step-specific implementation classes is safe
		EldaPDIStepMeta meta = (EldaPDIStepMeta) smi;
		EldaPDIStepData data = (EldaPDIStepData) sdi;

		super.dispose(meta, data);
	}

	private void recursiveCopy(File fSource, File fDest) {
		try {
			if (fSource.isDirectory()) {
				// A simple validation, if the destination is not exist then
				// create it
				if (!fDest.exists()) {
					fDest.mkdirs();
				}

				// Create list of files and directories on the current source
				// Note: with the recursion 'fSource' changed accordingly
				String[] fList = fSource.list();

				for (int index = 0; index < fList.length; index++) {
					File dest = new File(fDest, fList[index]);
					File source = new File(fSource, fList[index]);

					// Recursion call take place here
					recursiveCopy(source, dest);
				}
			} else {
				// Found a file. Copy it into the destination, which is already
				// created in 'if' condition above
				fSource.setExecutable(true); // code to set permises

				// Open a file for read and write (copy)
				FileInputStream fInStream = new FileInputStream(fSource);
				FileOutputStream fOutStream = new FileOutputStream(fDest);

				// Read 2K at a time from the file
				byte[] buffer = new byte[2048];
				int iBytesReads;

				// In each successful read, write back to the source
				while ((iBytesReads = fInStream.read(buffer)) >= 0) {
					fOutStream.write(buffer, 0, iBytesReads);

				}

				// Safe exit
				if (fInStream != null) {
					fInStream.close();
				}

				if (fOutStream != null) {
					fOutStream.close();
				}

				fDest.setExecutable(true); // code to set permises
			}
		} catch (Exception ex) {
			// Please handle all the relevant exceptions here
			logBasic(" ERROR " + ex + "in create output directory ");
		}
		
		//
	} // fin recursivy copy
	
	public void parametrizarUri(File fSource, File fDest, String nombre){
		logBasic(" config web.xml value "+nombre+ " in "+fDest);
			 try
	         {	
	         File file = new File(fSource+"/webapps/standalone/WEB-INF/web.xml");
	         BufferedReader reader = new BufferedReader(new FileReader(file));
	         String line = "", oldtext = "";
	         while((line = reader.readLine()) != null)
	             {
	             oldtext += line + "\r\n";
	         }
	         reader.close();

	         String phase  = oldtext.replaceAll("nuevoparametro", nombre+"::specs/"+nombre+".ttl");

	         FileWriter writer = new FileWriter(fDest+"/webapps/standalone/WEB-INF/web.xml");
	         writer.write(phase);


	         writer.close();

	     }
	     catch (IOException ioe)
	         {
	         ioe.printStackTrace();
	         logBasic(" ERROR " + ioe + "in add parametro in web.xml. ");
	     }
					
		
	}

	private void crearwar(String direc) {

		File buildFile = new File(
				"\\plugins\\steps\\EldaPDIStep\\axis_bujava.xml");
		// File buildFile = new
		// File("/plugins/steps/FusekiLoader/axis_bujava.xml");

		Project antProject = new Project();

		DefaultLogger consoleLogger = new DefaultLogger();
		consoleLogger.setErrorPrintStream(System.err);
		consoleLogger.setOutputPrintStream(System.out);
		consoleLogger.setMessageOutputLevel(Project.MSG_INFO);
		antProject.addBuildListener(consoleLogger);
		try {
			antProject.fireBuildStarted();

			antProject.setUserProperty("ant.file", buildFile.getAbsolutePath());
			antProject.init();
			ProjectHelper helper = ProjectHelper.getProjectHelper();
			antProject.addReference("ant.ProjectHelper", helper);
			helper.parse(antProject, buildFile);
			String target = "build-war";
			antProject.setUserProperty("build.dir", direc);
			antProject.executeTarget(target);

			antProject.fireBuildFinished(null);
		} catch (BuildException e) {
			antProject.fireBuildFinished(e);
			logBasic(" ERROR " + e);

		}

	}

	

	public List<String> cleanspaces(String limpiar) {

		// logError("nameontology "+meta.getNameOntology());
		String replace = limpiar.replace("[", "");

		String replace1 = replace.replace("]", "");

		String replace2 = replace1.replaceAll("\\s+", "");

		List<String> myList = new ArrayList<String>(Arrays.asList(replace2
				.split(",")));

		return myList;
	}
	
	
	public ArrayList<String> cargaListaTodos(String limpiar) {
		//no borra vacios
		// logError("nameontology "+meta.getNameOntology());
		System.out.println("/////////////////////////////////////////////////////////////////1") ;
		System.out.println("//////// LIMPIAR " + limpiar) ;
		String replace = limpiar.replace("[", "");

		String replace1 = replace.replace("]", "");
		System.out.println("//////// replace1 " + replace1) ;
		

		ArrayList<String> myList = new ArrayList<String>(Arrays.asList(replace1
				.split(",")));
		
		System.out.println("//////// lista size" + myList.size()) ;

		System.out.println("/////////////////////////////////////////////////////////////////2") ;
		return myList;
	}


}
